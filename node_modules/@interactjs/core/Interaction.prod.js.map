{
	"version": 3,
	"names": [
		"arr",
		"extend",
		"hypot",
		"warnOnce",
		"copyAction",
		"pointerUtils",
		"rectUtils",
		"InteractEvent",
		"PointerInfo",
		"_ProxyValues",
		"_ProxyMethods",
		"idCounter",
		"Interaction",
		"interactable",
		"element",
		"rect",
		"_rects",
		"edges",
		"_scopeFire",
		"prepared",
		"name",
		"axis",
		"pointerType",
		"pointers",
		"downEvent",
		"downPointer",
		"_latestPointer",
		"pointer",
		"event",
		"eventTarget",
		"prevEvent",
		"pointerIsDown",
		"pointerWasMoved",
		"_interacting",
		"_ending",
		"_stopped",
		"_proxy",
		"simulation",
		"pointerMoveTolerance",
		"doMove",
		"signalArg",
		"this",
		"move",
		"coords",
		"start",
		"newCoords",
		"prev",
		"cur",
		"delta",
		"velocity",
		"_id",
		"constructor",
		"scopeFire",
		"that",
		"key",
		"Object",
		"defineProperty",
		"get",
		"value",
		"args",
		"interaction",
		"pointerDown",
		"pointerIndex",
		"updatePointer",
		"pointerInfo",
		"type",
		"action",
		"interacting",
		"length",
		"options",
		"enabled",
		"getRect",
		"left",
		"right",
		"top",
		"bottom",
		"_doPhase",
		"phase",
		"pointerMove",
		"modification",
		"endResult",
		"duplicateMove",
		"page",
		"x",
		"y",
		"client",
		"dx",
		"dy",
		"getPointerIndex",
		"duplicate",
		"setCoordVelocity",
		"copyCoords",
		"setZeroCoords",
		"pointerUp",
		"curEventTarget",
		"test",
		"end",
		"removePointer",
		"documentBlur",
		"endPhaseResult",
		"stop",
		"currentAction",
		"pointerId",
		"getPointerId",
		"findIndex",
		"curPointer",
		"id",
		"getPointerInfo",
		"down",
		"push",
		"setCoords",
		"map",
		"p",
		"_now",
		"setCoordDeltas",
		"downTime",
		"timeStamp",
		"downTarget",
		"pointerExtend",
		"_updateLatestPointer",
		"splice",
		"destroy",
		"_createPreparedEvent",
		"preEnd",
		"_fireEvent",
		"iEvent",
		"_this$interactable",
		"fire",
		"addEdges",
		"deltaSource",
		"width",
		"height",
		"Date",
		"now"
	],
	"sources": [
		"Interaction.ts"
	],
	"sourcesContent": [
		"import type {\n  Element,\n  EdgeOptions,\n  PointerEventType,\n  PointerType,\n  FullRect,\n  CoordsSet,\n} from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { EventPhase } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport type { Interactable } from './Interactable'\nimport { PointerInfo } from './PointerInfo'\nimport type { ActionDefaults } from './options'\nimport type { Scope } from './scope'\nimport type { ActionName, ActionProps } from './types'\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = '',\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = '',\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: PointerType\n  event: PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction<never>\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction<ActionName> }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction<never>, event: Event, type: 'blur' }\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName | null = never> = Pick<\nInteraction<T>,\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName | null = ActionName> {\n  // current interactable being interacted with\n  interactable: Interactable | null = null\n\n  // the target element of the interactable\n  element: Element | null = null\n  rect: FullRect | null = null\n  _rects?: {\n    start: FullRect\n    corrected: FullRect\n    previous: FullRect\n    delta: FullRect\n  }\n  edges: EdgeOptions | null = null\n\n  _scopeFire: Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name: null,\n    axis: null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: PointerEventType | null = null\n\n  downPointer: PointerType = {} as PointerType\n\n  _latestPointer: {\n    pointer: PointerType\n    event: PointerEventType\n    eventTarget: Node\n  } = {\n      pointer: null,\n      event: null,\n      eventTarget: null,\n    }\n\n  // previous action event\n  prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n  _stopped = true\n  _proxy: InteractionProxy<T> | null = null\n\n  simulation = null\n\n  /** @internal */ get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = warnOnce(function (this: Interaction, signalArg: any) {\n    this.move(signalArg)\n  }, 'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  readonly _id: number = idCounter++\n\n  /** */\n  constructor ({ pointerType, scopeFire }: { pointerType?: string, scopeFire: Scope['fire'] }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get () {\n          return that[key]\n        },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {Boolean} Whether the interaction was successfully started\n   */\n  start<A extends ActionName> (action: ActionProps<A>, interactable: Interactable, element: Element): boolean {\n    if (\n      this.interacting() ||\n      !this.pointerIsDown ||\n      this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n      !interactable.options[action.name as keyof ActionDefaults].enabled\n    ) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element = element\n    this.rect = interactable.getRect(element)\n    this.edges = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped = false\n    this._interacting =\n      this._doPhase({\n        interaction: this,\n        event: this.downEvent,\n        phase: 'start',\n      }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove =\n      this.coords.cur.page.x === this.coords.prev.page.x &&\n      this.coords.cur.page.y === this.coords.prev.page.y &&\n      this.coords.cur.client.x === this.coords.prev.client.x &&\n      this.coords.cur.client.y === this.coords.prev.client.y\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this as unknown as Interaction<never>,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend(\n      {\n        pointer: this._latestPointer.pointer,\n        event: this._latestPointer.event,\n        eventTarget: this._latestPointer.eventTarget,\n        interaction: this,\n      },\n      signalArg || {},\n    )\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', {\n      event,\n      type: 'blur',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event?: PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer: any) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return this.pointerType === 'mouse' || this.pointerType === 'pen'\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, (curPointer) => curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false ? false : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(id, pointer, event, null, null)\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    } else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(\n      this.coords.cur,\n      this.pointers.map((p) => p.pointer),\n      this._now(),\n    )\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer: PointerType, event: PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) return\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  _updateLatestPointer (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy () {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  _createPreparedEvent<P extends EventPhase> (\n    event: PointerEventType,\n    phase: P,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  _fireEvent<P extends EventPhase> (iEvent: InteractEvent<T, P>) {\n    this.interactable?.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase<P extends EventPhase> (\n    signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> },\n  ) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = (signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type))\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') {\n      this.prevEvent = iEvent\n    }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  _now () {\n    return Date.now()\n  }\n}\n\nexport default Interaction\nexport { PointerInfo }\n"
	],
	"mappings": "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"
}